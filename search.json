[{"title":"定投","path":"/2024/03/27/定投/","content":"年化率 10 % 8% 定投基数 4000元 4000元 定投年限 10年 10年 总利润 830208元 740663元 总成本 480000元 480000元 纯利润 350208元 260663元 收益率 72.96% 54.3% 收益100%所需时间 12年06月 15年08月 影响我们投资的主要因素有一下三个： 年化率 定投基数 持有时间 三种因素里面，年化率影响最大，持有时间次之，最次之是定投基数。 年化率越高，指数爆炸效应来的越早，收益率爬升的快，但是年化率与个人选择无关，指数基金的年化率基本在8%-15%，这是个人无法改变的，我们能做的无非是选择一个具有稳定收益率的基金进行投资。 持有时间越长，收益率越高，尤其是后期（到达指数爆炸点，收益开始爬坡）。不过上述算法是基于每年收益平均的情况下计算出来的。 实际上股市是周期性的。在一个周期内，大部分时间股市是起伏不定的，只有在非常窄的一段时间内会急剧爬升，我们定投的目的就是要用周期性投资稀释自己的成本（避免买在最高点），并且等到股市上升的时间来临的时候吃利润。这就是长期持有的原因。因此，最少持有一个周期才能赚到股市的钱，通常一个周期需要五六七八年。 定投基数取决于自身，前期入门可以少量定投，后续再追加每次定投的量。总之不要 all in。 总结：长期定投指数基金，是普通人在最小的风险下赚到股市的钱的最好方法。","tags":["投资"]},{"title":"SQL语法通关","path":"/2024/03/24/SQL语法通关/","content":"语法 示例 备注 简单查询 SELECT * FROM student; 查询：字段起别名 SELECT name AS 学生姓名, age AS 学生年龄 FROM student; 查询：运算 SELECT name, score, score * 2 AS double_score FROM student; 条件查询：WHERE SELECT name, score FROM student WHERE name&#x3D;’鱼皮’ 条件查询：运算符 SELECT name, age FROM student WHERE age BETWEEN 25 AND 30 &gt;, &lt;, &#x3D;, !&#x3D;, BETWEEN a AND b 条件查询：空值 SELECT name, age, score FROM student WHERE name is NOT null; is null ；is NOT null 条件查询：模糊查询 SELECT name, score FROM student WHERE name NOT LIKE “%李%” %匹配多个字符；_匹配单个字符 条件查询：逻辑运算 SELECT name, score FROM student WHERE name LIKE “%李%” OR score &gt; 500; AND; OR; NOT 去重 SELECT DISTINCT class_id, exam_num FROM student; （根据class_id, exam_num 组合进行去重） DISTINCT 排序 SELECT name, age, score FROM student ORDER BY score desc, age ASc; desc：降序; ASc：升序 截断和偏移 SELECT name, age FROM student ORDER BY age ASc LIMIT 1,3; LIMIT a, b; 从索引位置a开始，截取b个tuple 条件分支 SELECT name, CASE WHEN (age &gt; 60) THEN’老同学’ WHEN (age &gt; 20) THEN’年轻’ ELSE ‘小同学’ END AS age_level FROM student ORDER BY name ASC; CASE WHEN THEN END AS xxx 时间函数 SELECT name, DATE() AS ‘当前日期’ FROM student; pg语法：SELECT CURRENT_DAT,E;（查日期），SELECT now()；（查时间） 字符串处理 SELECT id, name, UPPER(name) AS upper_name FROM student WHERE name&#x3D;’热dog’; UPPER(name)，LOWER(name), LENGTH(name) 聚合函数 SELECT SUM(score) AS total_score, AVG(score) AS avg_score, MAX(score) AS max_score, MIN(score) AS min_score FROM student; SUM, COUNT, AVG, MAX, MIN 分组聚合：单字段分组 SELECT class_id, AVG(score) AS avg_score FROM student GROUP BY class_id; （根据class_id分组人，然后计算班级avg分数） GROUP BY 分组聚合：多字段分组 SELECT class_id, exam_num, COUNT(name) AS total_num FROM student GROUP BY class_id, exam_num; 分组聚合：HAVING子句 SELECT class_id, SUM(score) AS total_score FROM student GROUP BY class_id HAVING total_score &gt; 150; HAVING用于分组之后进行过滤；WHERE是在分组之前进行过滤 关联查询： CROSS JOIN SELECT s.name AS student_name, s.age AS student_age, s.class_id AS class_id, c.name AS class_name FROM student s CROSS JOIN class c 将两张表关联起来进行查询 关联查询：INNER JOIN SELECT s.name AS student_name, s.age AS student_age, s.class_id AS class_id, c.name AS class_name, c.level AS class_level FROM student s JOIN class c on s.class_id &#x3D; c.id SELECT table t1 JOIN table t2 on t1.id &#x3D; t2.num （内联，两表都有的才展示） 关联查询：OUTER JOIN SELECT s.name AS student_name, s.age AS student_age, s.class_id AS class_id, c.name AS class_name, c.level AS class_level FROM student s LEFT JOIN class c on s.class_id &#x3D; c.id; left OUTER JOIN; right OUTER JOIN 子查询 SELECT name, score, class_id FROM student WHERE class_id in (SELECT DISTINCT id FROM class); 子查询的结果作为条件或者数据来源，然后执行外部查询。 子查询：exists SELECT name, age, class_id FROM student WHERE NOT exists SELECT * FROM class WHERE student.class_id &#x3D; class.id; exists子查询，用于检查主查询语句的结果是否满足条件，如果满足，exists返回true，主查询返回结果。 组合查询 SELECT name, age, score, class_id FROM student UNION ALL SELECT name, age, score, class_id FROM student_new; UNION，将两个SELECT的结果去重输出；UNION ALL 不去重 开窗函数：SUM OVER SELECT id, name, age, score, class_id, AVG(score) OVER (PARTITION BY class_id) AS class_avg_score FROM student; 开窗函数：允许对分组进行计算并保留原结果集 开窗函数：SUM OVER ORDER BY SELECT id, name, age, score, class_id, SUM(score) OVER (PARTITION BY class_id ORDER BY score ASc) AS class_SUM_score FROM student; 分组计算并排序 开窗函数：RANK SELECT id, name, age, score, class_id, RANK() OVER (PARTITION BY class_id ORDER BY score desc) AS ranking FROM student; RANK：按照某一列分组，然后按照某一字段进行排名 开窗函数 ：ROW_NUMBER SELECT id, name, age, score, class_id, ROW_NUMBER() OVER (PARTITION BY class_id ORDER BY score desc) AS row_number FROM student; 查询结果集中的每一行分配一个唯一的序号 开窗函数：LAG&#x2F; LEAD SELECT id, name, age, score, class_id, LAG(name, 1, null) OVER (PARTITION BY class_id ORDER BY score desc) AS prev_name, LEAD(name, 1, null) OVER (PARTITION BY class_id ORDER BY score desc) AS next_name FROM student; LAG&#x2F;LEAD用于获取当前行前、后的值，比较相邻行。","tags":["计算机技术"]},{"title":"跟着刘仲敬学历史","path":"/2024/03/23/跟着刘仲敬学历史/","content":"大一统从暴秦开始，从未走出秦政的阴影，给华夏世界带来了永无止境的灾难。 大一统是野心家谋杀众多有机共同体的血腥现场建立起来的，只有不断破坏社会生态的自然发展才能维持。没有秦政的残酷收割，民间社会势必不断发育产生富人和强人。 小邦的国民注定不能内心服从邻国的统治，大一统需要另一种居民，他们完全不在乎统治者的更换，大一统需要的是顺民。而顺民在大一统之下享有的自由，远远低于古今大多数被征服民族在征服者铁蹄下享有的自由。 任何地方的超前发展，都是统一的隐患。向上看起很难，向下看齐很容易。因此大一统的社会不允许地方过于富强。 只有分裂时代，小邦为了竞争的理由，才会允许昙花一现的经济进步出现。宋朝其实是有过机会的，但是宋朝用吏制国家和垄断贸易制度将南方繁荣的经济削弱。在统治者眼里，除了京师，谁也不应该强大。结果就是到了鸦片战争，英国人的军舰打开了国门。 反观历史，我们可以发现，当年吴越的人口远远超过英国、泉州的人口远远超过伦敦。如果大一统帝国曾经为吴楚、七国、南朝、十国、郑成功父子留下机会，世界并非一定属于欧洲。 从历史上看，大明和大清的对应物不是英格兰或者法兰西，而是神圣罗马帝国和普世天主教会。中国是相当于全欧州的文明体，而不是地方性的民族国家。 马克思主义本来就是边缘理论，只有非主流人群才会认真对待。 在苏联实力不及之处，马克思主义从来不曾有过变成主流的机会。有些人把马克思主义看的很重要，是因为他们对世界思想史缺乏了解。 共同体的价值认同是民主的前提。民国一开始建立在流沙上，以大清版图作为构建大中华的基础，本质上是政治决断，民意和历史的基础并不存在。如果当时听任内部因素自然发展，民国解体的可能性显然占压到优势。袁世凯重建中央集权的尝试失败后，1923年宪法进一步扩大了各省的权利。 二十年代的趋势是东南各省制宪工作顺利进展，沿海地区经济迅速起飞，东北和内地的差距稳步扩大，蒙藏独立性日益增强。听其自然，大清版图大概会建立四五个独立政权，满洲（很可能包括内蒙）只需要二三十年，就会成为东亚第一号工业强国。东南各省各自行宪后，可能以1923年宪法为蓝本，建立模范联邦国家，建立外贸取向的现代化经济。蒙古和西藏各自独立建国。北方和内部各省虽然会陷入长期混乱和贫困，但共同体认同会随着时间自然形成。 但民国的精英更加倾向于大中华主义，因此对自己的悲剧负极大责任。但是我们不能忘记，中国的命运主要是由国际体系的演变造成的。如果以英国为首的列强不能或不愿维护远东条约体系，和平演变的自然趋势肯定会遭到破坏。二十年代，苏联和国民党是主要破坏者；三十年代，日本及其支持的满蒙独立派、北洋联省派开始报复；共产党作为苏联供养的集团，在夹缝中投机。苏联是主要责任者，国民党是次要责任者。 就算没有战争，民国黄金十年也不能一直持续下去。袁世凯路线的长期结果大概是：经过一段时间的经济发展，浙江、江苏、广东这样的省份慢慢独立出去。北方依靠权威主义和军人政府无法瓦解南方的分离主义。照这种情况发展，中国分裂是早晚的事。袁世凯没有国民党和共产党的组织力量。这样，中国通过某种比较合理的方式逐步分裂。沿海地区大概就变成泰国和马来西亚那种情况，内地可能还是长期处于强权的统治下，有些地方会被俄罗斯或者日本吞并。这对沿海各地区并非不是一件好事，因为国家统一的经济意义就是落后的内地剥削东南发达地区。 早期民国之所以没有出现改朝换代例行的割据争雄的局面，任何军阀都需要跟公使团交涉，在国际社会面前维持一个统一国家的假象。 中国内战很快就造成了苏日争霸东亚、列强不断退缩的局面，没有获得苏日任何一方支持的政治势力寻思萎缩、消失。 只有在中国迅速实现军事和军事工业近代化的前提下，革命外交才能取得预期的效果。在当时的历史约束条件下，只有一种路径可以在一代人之内将农业国改造为军事工业强国 — — 那就是斯大林模式，其代价是对农村施行超经济剥夺。其他任何发展模式都需要更长的时间积累基础。国民政府一面要求在短期内废除不平等条约，一面无法在短期内实现军事工业化。这种自相矛盾的政策注定了自身的毁灭。她在短暂和平时期取得的建设成就得不到和平外交或强大武力的保护，实际上已经破坏殆尽。如果没有在统计数据中加入日本建立的东北重工业，中国 1945 年的各项经济指标还会更加恶劣。 只有在多国势力接近于平衡的情况下，国际体系才能维持相对的稳定。在原有平衡遭到破坏、新的平衡未能建立的时期，胜利者通常得到的不是国际平等、而是战争与动荡。弱小国家更有可能为了安全，寻找新的霸权，而不是追求平等。在霸权冲突的不稳定的地区，霸权的转移或毁灭通常导致弱小国家内部的革命。 二战在东亚地区的后果是：经过日本的侵占和国民政府的废除不平等条约，西欧各国的条约利益已经荡然无存。中国经济、社会全面崩溃，日本彻底毁灭。为更加强大的苏联留下了舞台。美国是最后一个强大的西方国家，但是他面对亚洲大陆的地缘形势，最佳选择莫过于离岸观察，奉行不干涉政策。 历史发展到这一步，随后的事态已经不难预测。日本在东北地区的遗产必然落入苏联手里，在太平洋的征服必定落在美国人手里。如果中国发生内战，掌握东北重工业基地的一方享有绝对优势。而东北的仲裁权在苏联手里。 国民政府这时除了她实际上采取的行动，只有另外两种选择。她可以实施捷克式的强烈亲苏政策，能够满足苏联对东北、内蒙、新疆的要求，这样虽然能够避免内战和革命，但无法避免贝奈斯式的结局：通过联合政府实现体面失败，最终加入苏联卫星国的行列。或者，她可以试图夸大苏联霸权的威胁，说服美国更早、更多地干涉，这样或许能保存台湾以外的某些沿海土地，甚至南中国。不过，在中国法定领土同时包括东北和台湾（也就是横跨内亚和太平洋）的前提下，跨海分治就是最合理、最可能稳定的结局。 国民党需要苏联的金钱和武器，半心半意地接受列宁主义。而共产党一开始就是共产国际的分支，不仅完全依靠苏联的资助，而且生杀大权都掌握在苏联手中。这些选择都是出于现实政治的考虑，一点都不乌托邦。 欧洲由封建自由的各阶级分权演化为立宪君主制，这种可能性在秦政以后的中国已经消失，虽然在周政下或许曾经存在。你不可能在近代中国复制中世纪晚期欧洲的历史背景。欧洲思想家是事后的总结者，不是事前的设计师。英国宪法是贵族、新教徒等社会集团博弈出来的，不是理论家设计出来的。历史创造思想，思想创造不了历史。 对列宁主义政党而言，党内民主和自行解散是没有区别的。 真正的马克思主义者，打不赢内战，他们只会组织巴黎公社，这样的自治社团联合起来顶多是一个联邦国家，不可能变成中国和苏联这样的中央集权国家。实现这种功能马克思主义，中国肯定要解体。让马克思自己发言，他肯定会说俄罗斯就是该解体，东方帝国最好给英国殖民，否则让俄国人吞并，还不如交给英国人。 布尔什维克组织的设计目的就是破坏所有社会组织，然后才能实现全面格式化。格式化如果彻底就是红色高棉那种，社会完全解体。张闻天治理江西中央苏区，把人口减少了三分之一，就等于中国的红色高棉。 改革开发不是资本主义，因为资本主义是一个法权体系，原来的满洲国或者上海租界有这样的体系，现在没有。中国的企业按照中国以外任何国家的法院来看都应该叫做黑社会，企业老总就是党和黑社会的杂交品种。哪怕拿到非洲，这套手段都会引起暴动。前殖民地国家看似落后，单他们的法律是英国人或者法国人制定的。中国模式依靠列宁主义控制劳动力，吸引低端产业。这是布尔什维克的最后一个橘子。人口枯竭后，印度尼西亚或者缅甸的年轻人口就会取代我们。 中国道路摸索成功自然尤其道理，但是这些理由在马克思主义当中找不到。 流沙社会没有共同体，因为你没有确定的身份和利益。 美国是今天的罗马，在国内是共和国，在世界是帝国。今天相当于共和国晚期和帝国前夜。 世界秩序不能缺少罗马帝国。 中国世纪已经过去了，今天所谓中国，无非像阿拉伯人的埃及一样借用了古老荣光的名字。中国是文明耗尽以后的灰烬，能否构成新文明的原材料尚在未定之中。他是文明的输入者，而不是生产者，他目前没有足够的德行和能力诚实的学习，没有表现出将来可能产生文明的任何迹象。至于现代政治意义上的崛起，那是一条自取灭亡的捷径。 东方无法维持自由必须的秩序，陷于拜占庭式的专治和停滞，这种情况当然是人类的灾难。 如果共同体的主权属于全体国民，国民就必须有高度的价值认同。如果没有或不能维持价值认同，共和国就不是此时此地最理想的政体。在现实世界中，情况差不多就是这样。 进一步推论，只有两种解决方法。要么发动输出民主价值观的十字军战争，要么在没有正确价值认同的地区实施变相的帝国主义。除此之外，任何手段都是后患无穷的权宜之计。十字军战争和帝国主义的主体必须具备非常特殊的性质，除了美国以外谁也无法胜任。 英格兰宪政是不能移植的，即使是拉美国家也不行，除非以殖民主义的方式。 统治是必然的，自治不是必然的。世界不是平的，政治德性的落差构成了帝国存在的正当性基础。不能自治的结果肯定是被人统治或者灭亡。只有各邦自治能力相等的情况下，世界才能不需要帝国主义。","tags":["读书笔记"]},{"title":"函数指针","path":"/2024/03/21/函数指针/","content":"什么是函数指针？首先，它是一个指针，这个指针指向的是一个函数。 1int (*func)(int a, int b); /* 这是一个函数指针，指向的函数有两个int型入参，返回值也是int */ 函数指针有什么用？ 回调函数 转移表 回调函数上一节讲到的c语言实现通用链表，就用到了回调函数。 链表存的元素未知，因此用一个void* data来表示一个指向未知类型的指针。 1234typedef struct Node &#123; void* data; struct Node* next;&#125; Node; 实现通用链表之后，需要创建接口来使用。因此一个接口需要对应多种类型的函数来实现。具体看《c语言实现通用链表》 转移表转移表：就是创建一个函数指针数组。数组每一个元素都指向一种类型的函数。可以替代switch的功能。 举例子：实现一个简单的计算器，拥有加减乘除的功能。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;unordered_map&gt;int add(int a, int b) &#123; return a + b;&#125;int stract(int a, int b) &#123; return a - b;&#125;int multp(int a, int b) &#123; return a * b;&#125;int divid(int a, int b) &#123; return a / b;&#125;int (*FuncInt[])(int a, int b) = &#123;add, stract, multp, divid&#125;; /* 转移表 */std::unordered_map&lt;char, int&gt; mp = &#123; &#123;&#x27;+&#x27;, 0&#125;, &#123;&#x27;-&#x27;, 1&#125;, &#123;&#x27;*&#x27;, 2&#125;, &#123;&#x27;/&#x27;, 3&#125;&#125;int main() &#123; int a = 1; int b = 2; char ch = &#x27;+&#x27;; return FuncInit[mp[ch]](a, b); /* 从函数指针数组中选取合适的函数调用 */&#125;","tags":["计算机技术"]},{"title":"c语言实现通用链表","path":"/2024/03/19/c语言实现通用链表/","content":"c语言实现通用链表，用到了指针，函数指针。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; /* 实现通用链表 */ /* 定义节点 */ typedef struct Node &#123; void *data; struct Node* next; &#125; Node; /* 定义链表 */ typedef struct LinkedList &#123; Node *head; int size; &#125; LinkedList; void InitLinkedList(LinkedList* list) &#123; list-&gt;head = NULL; list-&gt;size = 0; &#125; void Append(LinkedList* list, void* data) &#123; Node *newNode = (Node *)malloc(sizeof(Node)); newNode-&gt;data = data; newNode-&gt;next = NULL; /* 如果链表为空 */ if (list-&gt;head == NULL) &#123; list-&gt;head = newNode; &#125; else &#123; Node *current = list-&gt;head; while (current-&gt;next != NULL) &#123; current = current-&gt;next; &#125; current-&gt;next = newNode; &#125; list-&gt;size++; &#125; void PrintLinkedList(LinkedList* list, void (*PrintFunc)(void*)) &#123; Node* current = list-&gt;head; while (current != NULL) &#123; PrintFunc(current-&gt;data); current = current-&gt;next; &#125; &#125; void FreeLinkedList(LinkedList* list, void (*FreeFunc)(void*)) &#123; Node *current = list-&gt;head; while (current != NULL) &#123; Node* temp = current; current = current-&gt;next; if (FreeFunc != NULL) &#123; FreeFunc(temp-&gt;data); &#125; free(temp); &#125; list-&gt;head = NULL; list-&gt;size = 0; &#125; void PrintInt(void* data) &#123; int *value = (int *)data; print(&quot;%d&quot;, *value); &#125; void FreeInt(void* data) &#123; free(data); &#125; int main() &#123; LinkedList list; InitLinkedList(&amp;list); /* 插入元素 */ for (int i = 0; i &lt;= 5; i++) &#123; int *value = (int *)malloc(sizeof(int)); *value = i; Append(&amp;list, value); &#125; /* 打印元素 */ printf(&quot;Linkede list: &quot;); PrintLinkedList(&amp;list, PrintInt); /* 释放链表 */ FreeLinkedList(&amp;list, FreeInt); return 0; &#125;","tags":["计算机技术"]},{"title":"c++与多线程","path":"/2024/03/17/c-与多线程/","content":"多线程有什么问题？多线程相当于一个并发的过程，同时执行多个任务，并且多个任务之间共享资源。 如果是同时写入某个变量的时候，就需要解决同步的问题。【不同线程的执行顺序，会导致不同的结果，这就是竞争条件】 多线程同步：同一时间仅可以有一个线程访问同一个资源。 有几种解决办法？互斥锁：全局对象，有两种状态 lock 和 unlockstd::mutex 是C++标准库提供的互斥锁类，用于实现多线程的互斥访问。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx; // 创建一个互斥锁对象,通常来说是一个全局变量.void printNumbers(int id) &#123; for (int i = 0; i &lt; 5; ++i) &#123; mtx.lock(); // 获取锁 std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot;: &quot; &lt;&lt; i &lt;&lt; std::endl; mtx.unlock(); // 释放锁 &#125;&#125;int main() &#123; std::thread t1(printNumbers, 1); // 创建线程1 std::thread t2(printNumbers, 2); // 创建线程2 t1.join(); // 等待线程1结束 t2.join(); // 等待线程2结束 return 0;&#125; 条件变量条件变量和互斥量配合使用。当一个线程需要等待另一个线程的特定条件发生时，可以使用条件变量进行多线程通信 std::condition_variable 是C++标准库提供的条件变量类。 std::unique_lockstd::mutex和std::condition_variable一起使用，实现条件变量和互斥锁的复杂的线程同步。 当满足条件变量时，本线程唤醒等待线程，避免等待线程不停的获取互斥锁，避免等待线程处于忙等待状态消耗cpu资源。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::mutex mtx; // 互斥锁std::condition_variable cv; // 条件变量bool ready = false; // 条件变量需要等待的条件void printMessage() &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); while (!ready) &#123; cv.wait(lck); // 等待条件变量满足 &#125; // 条件满足后输出消息 std::cout &lt;&lt; &quot;Message received!&quot; &lt;&lt; std::endl;&#125;void setMessageReady() &#123; // 假装做了一些准备工作 std::this_thread::sleep_for(std::chrono::seconds(2)); &#123; std::lock_guard&lt;std::mutex&gt; lck(mtx); ready = true; // 设置条件变量为true &#125; cv.notify_one(); // 唤醒等待的线程&#125;int main() &#123; std::thread t1(printMessage); // 创建打印消息的线程 std::thread t2(setMessageReady); // 创建设置条件变量的线程 t1.join(); // 等待打印消息的线程结束 t2.join(); // 等待设置条件变量的线程结束 return 0;&#125; 在这个例子中，我们使用了std::condition_variable来创建一个条件变量cv，并定义了一个布尔变量ready作为条件。 在printMessage函数中，线程首先获取了互斥锁mtx，然后通过cv.wait()等待条件变量满足。 在setMessageReady函数中，线程首先做了一些准备工作（这里简单地模拟了一下），然后设置了条件变量ready为true，并通过cv.notify_one()唤醒了等待的线程。 在main函数中，我们创建了两个线程t1和t2，分别执行打印消息和设置条件变量的工作。通过条件变量的机制，确保了线程在合适的时机等待和唤醒，避免了忙等待的情况。 线程调用 wait()的时候，会释放互斥锁，同时也释放了CPU资源。这意味着在等待期间，线程不会消耗cpu时间，而是睡眠状态，等待被唤醒。 notify_one或者notify_all 函数的作用是唤醒等待条件变量的线程，唤醒之后尝试获取互斥锁，然后继续执行。 信号量信号量是一种计数器，用于控制同时访问某一资源的线程数量。 信号量的作用类似于条件变量，区别是：条件变量只有true和false两种状态，但是信号量可以表示n个状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;chrono&gt;#include &lt;vector&gt;#include &lt;random&gt;class Semaphore &#123;public: Semaphore(int count = 0) : count_(count) &#123;&#125; void notify() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); count_++; condition_.notify_one(); &#125; void wait() &#123; std::unique_lock&lt;std::mutex&gt; lock(mutex_); //创建lock对象，并在创建时对mutex_对象加锁。 while (count_ ** 0) &#123; condition_.wait(lock); &#125; count_--; &#125;private: std::mutex mutex_; std::condition_variable condition_; int count_;&#125;;Semaphore semaphore(3); // 初始化信号量，允许同时有3个线程执行临界区代码void threadFunction(int id) &#123; semaphore.wait(); // 等待信号量 std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; is executing critical section.&quot; &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟临界区代码执行时间 std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; finished executing critical section.&quot; &lt;&lt; std::endl; semaphore.notify(); // 释放信号量&#125;int main() &#123; std::vector&lt;std::thread&gt; threads; // 创建多个线程，尝试同时执行临界区代码 for (int i = 0; i &lt; 10; ++i) &#123; threads.emplace_back(threadFunction, i + 1); &#125; // 等待所有线程执行结束 for (auto&amp; thread : threads) &#123; thread.join(); &#125; return 0;&#125; 定义了一个 Semaphore 类，其中包含 notify() 和 wait() 方法来操作信号量。在 main() 函数中，我们创建了一个信号量对象 semaphore，初始值为3，表示允许同时有3个线程执行临界区代码。然后我们创建了10个线程，每个线程都尝试调用 semaphore.wait() 等待信号量，然后执行临界区代码，并在执行结束后调用 semaphore.notify() 释放信号量。 读写锁允许多个线程同时读； 当一个线程写时，锁定资源，不允许其他线程读。 std::shared_mutex 是 C++11 标准库中引入的读写锁（Read-Write Lock）类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;shared_mutex&gt;#include &lt;vector&gt;#include &lt;chrono&gt;std::shared_mutex rwMutex;std::vector&lt;int&gt; sharedData;void readData(int id) &#123; // 读取共享数据 std::shared_lock&lt;std::shared_mutex&gt; lock(rwMutex); std::cout &lt;&lt; &quot;Reader &quot; &lt;&lt; id &lt;&lt; &quot; reads: &quot;; for (const auto&amp; data : sharedData) &#123; std::cout &lt;&lt; data &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl;&#125;void writeData(int id) &#123; // 写入共享数据 std::unique_lock&lt;std::shared_mutex&gt; lock(rwMutex); sharedData.push_back(id); std::cout &lt;&lt; &quot;Writer &quot; &lt;&lt; id &lt;&lt; &quot; writes: &quot; &lt;&lt; id &lt;&lt; std::endl;&#125;int main() &#123; const int numReaders = 3; const int numWriters = 2; std::vector&lt;std::thread&gt; readers; std::vector&lt;std::thread&gt; writers; // 创建读者线程 for (int i = 0; i &lt; numReaders; ++i) &#123; readers.emplace_back(readData, i); &#125; // 创建写者线程 for (int i = 0; i &lt; numWriters; ++i) &#123; writers.emplace_back(writeData, i); &#125; // 等待所有读者线程结束 for (auto&amp; reader : readers) &#123; reader.join(); &#125; // 等待所有写者线程结束 for (auto&amp; writer : writers) &#123; writer.join(); &#125; return 0;&#125; 上述代码中，使用std::shared_mutex实现读写锁。 在readData中，使用std::shared_lock获取读锁并读取数据。允许多个线程持有读锁。 在writeData中，使用std::unique_lock获取写锁饼写入数据。只允许一个线程获取到写锁。 原子操作C++11 标准引入了原子操作的支持，提供了 std::atomic 类模板，用于创建原子类型的对象，以及一系列的原子操作函数，如 load、store、exchange、compare_exchange_weak 等，用于对原子类型的对象进行读取、写入和比较交换等操作。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;atomic&gt;#include &lt;thread&gt;std::atomic&lt;int&gt; counter(0); // 原子类型的计数器void incrementCounter() &#123; for (int i = 0; i &lt; 1000; ++i) &#123; counter++; // 自增操作是原子的 &#125;&#125;int main() &#123; std::thread t1(incrementCounter); std::thread t2(incrementCounter); t1.join(); t2.join(); std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; counter &lt;&lt; std::endl; return 0;&#125; 上述代码中，两个线程对count进行自增运算。 由于count是原子类型，因此不会有竞争条件出现，count的最终结果是2000. 消息队列生产者-消费者模式 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;thread&gt;std::queue&lt;int&gt; messageQueue;std::mutex mtx;std::condition_variable cv;void producer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); messageQueue.push(i); std::cout &lt;&lt; &quot;Produced message: &quot; &lt;&lt; i &lt;&lt; std::endl; lock.unlock(); cv.notify_one(); // 通知消费者消息已经生产 std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟生产过程 &#125;&#125;void consumer() &#123; for (int i = 0; i &lt; 10; ++i) &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); cv.wait(lock, []&#123; return !messageQueue.empty(); &#125;); // 等待消息队列非空 int message = messageQueue.front(); messageQueue.pop(); std::cout &lt;&lt; &quot;Consumed message: &quot; &lt;&lt; message &lt;&lt; std::endl; &#125;&#125;int main() &#123; std::thread producerThread(producer); std::thread consumerThread(consumer); producerThread.join(); consumerThread.join(); return 0;&#125; 在这个示例中，producer 函数负责生产消息并将其推送到消息队列中，而 consumer 函数负责从消息队列中获取消息并进行消费。使用互斥锁 std::mutex 和条件变量 std::condition_variable 来实现生产者和消费者之间的同步。生产者在生产消息后通过条件变量通知消费者，消费者在等待消息队列非空时通过条件变量等待通知。 降低锁对系统性能影响的方法包括： 减少锁持有时间：在使用锁的情况下，尽量减少锁的持有时间可以降低锁争用的概率，从而提高系统的并发性能。可以通过将锁的作用范围缩小到必要的最小范围来实现。 细粒度锁：将共享数据分割为多个小的数据单元，并为每个数据单元使用不同的锁。这样可以减少线程之间的竞争，提高并发性能。 使用合适的锁：自旋锁是一种在锁被占用时不立即阻塞线程，而是通过循环等待锁释放的方式，以减少线程切换的开销。在锁的持有时间较短且并发度较高的情况下，自旋锁可以提供更好的性能。以及对于读多写少的情况，读写锁好于互斥锁。 锁分级：根据不同的访问模式和临界区的复杂性，使用不同级别的锁。例如，可以使用粗粒度锁来保护整个数据结构的一致性，再结合细粒度锁来保护数据结构中的特定部分。 避免锁嵌套。减少死锁和锁争抢。 使用无锁的数据结构。比如基于原子操作实现的无锁队列、无锁栈等。","tags":["计算机技术"]},{"title":"二叉树深度搜索和广度搜索","path":"/2024/03/09/二叉树深度搜索和广度搜索/","content":"广度优先算法队列经常被用来实现二叉树的广度优先搜索。首先将二叉树的根节点插入队列。然后每次从队列中取出一个节点遍历。如果该节点有子节点，则将子节点插入队列。重复这个过程，直到队列被清空，此时二叉树所有的节点都已经遍历完。 12345678910111213141516171819202122class Solution &#123;public: int findBottomLeftValue(TreeNode* root) &#123; queue&lt;TreeNode*&gt; qu; vector&lt;int&gt; res; qu.push(root); while (!qu.empty()) &#123; TreeNode* node = qu.front(); qu.pop(); if (node-&gt;left) &#123; qu.push(node-&gt;left); &#125; if (node-&gt;right) &#123; qu.push(node-&gt;right); &#125; res.push_back(node-&gt;val); &#125; return res; &#125;&#125;; 深度优先算法123456789101112131415161718192021222324252627282930313233343536373839/* 中序遍历——递归 */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; dfs(root, res); return res; &#125; void dfs(TreeNode* node, vector&lt;int&gt;&amp; res) &#123; if (node) &#123; dfs(node-&gt;left, res); res.push_back(node-&gt;val); dfs(node-&gt;right, res); &#125; &#125;&#125;;/* 中序遍历——栈 */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stk; while (root != nullptr || !stk.empty()) &#123; while (root != nullptr) &#123; stk.push(root); root = root-&gt;left; &#125; root = stk.top(); stk.pop(); res.push_back(root-&gt;val); root = root-&gt;right; &#125; return res; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738/* 前序遍历——递归 */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; dfs(root, res); return res; &#125; void dfs(TreeNode* node, vector&lt;int&gt;&amp; res) &#123; if (node) &#123; res.push_back(node-&gt;val); dfs(node-&gt;left, res); dfs(node-&gt;right, res); &#125; &#125;&#125;;/* 前序遍历——栈 */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stk; while(root != nullptr || !stk.empty()) &#123; while (root != nullptr) &#123; res.push_back(root-&gt;val); stk.push(root); root = root-&gt;left; &#125; root = stk.top(); stk.pop(); root = root-&gt;right; &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 后序遍历——递归 */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; dfs(root, res); return res; &#125; void dfs(TreeNode* node, vector&lt;int&gt;&amp; res) &#123; if (node) &#123; dfs(node-&gt;left, res); dfs(node-&gt;right, res); res.push_back(node-&gt;val); &#125; &#125;&#125;;/* 后序遍历——栈 */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; res; if (root == nullptr) &#123; return res; &#125; stack&lt;TreeNode *&gt; stk; TreeNode *prev = nullptr; while (root != nullptr || !stk.empty()) &#123; while (root != nullptr) &#123; stk.emplace(root); root = root-&gt;left; &#125; root = stk.top(); stk.pop(); if (root-&gt;right == nullptr || root-&gt;right == prev) &#123; res.emplace_back(root-&gt;val); prev = root; root = nullptr; &#125; else &#123; stk.emplace(root); root = root-&gt;right; &#125; &#125; return res; &#125;&#125;;","tags":["计算机技术"]},{"title":"常见的排序算法","path":"/2024/03/09/常见的排序算法/","content":"冒泡排序123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; arr = &#123;2, 7, 5, 3, 9, 4&#125;; /* 冒泡排序: * 每次比较前后两个元素大小并排序，每循环一遍，确定将最大值排在后面，时间复杂度O(n^2) * 稳定排序 */ for (int i = 0; i &lt; arr.size(); i++) &#123; bool flag = false; for (int j = 0; j &lt; arr.size() - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; &#125; &#125; if (!flag) break; &#125; cout &lt;&lt; &quot;排序之后：&quot;; for(auto a : arr) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 选择排序12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; arr = &#123;2, 7, 5, 3, 9, 4&#125;; /*选择排序 * 每遍历一次数组，将最小值放在最前面。时间复杂度O(n^2) * 不稳定排序 */ for (int i = 0; i &lt; arr.size(); i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.size(); j++) &#123; if(arr[minIndex] &gt; arr[j]) &#123; minIndex = j; &#125; &#125; int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; cout &lt;&lt; &quot;排序之后：&quot;; for(auto a : arr) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 插入排序12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; arr = &#123;2, 7, 5, 3, 1, 4&#125;; /*插入排序 * 将未排序数组一分为二，前半部分是未排序的，后半部分是排好序的。 * 往后遍历，每次保证前半部分已拍好序的长度累加。时间复杂度是O(n^2) * 插入排序在数组顺序不是很乱的情况下是比较快的。 * 稳定排序 */ for (int i = 0; i &lt; arr.size() - 1;i++) &#123; for (int j = i + 1; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; int temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; &#125; &#125; &#125; cout &lt;&lt; &quot;排序之后：&quot;; for(auto a : arr) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 归并排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void MergeSort(vector&lt;int&gt;&amp; res, int p, int r);void MergeArray(vector&lt;int&gt;&amp; res, int p, int q, int r);int main() &#123; vector&lt;int&gt; arr = &#123;2, 71, 15, 23, 12, 4&#125;; /* 归并排序 * 分治思想：将大数组分成左右两个数组分别排序，然后合并。 * 时间复杂度：o(nlogn),空间复杂度：o(n) */ int n = arr.size(); MergeSort(arr, 0, n); cout &lt;&lt; &quot;排序之后：&quot;; for(auto a : arr) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return 0;&#125;void MergeSort(vector&lt;int&gt;&amp; vec, int p, int r) &#123; if(p &gt;= r) return; int q = p + (r - p) / 2; MergeSort(vec, p, q); MergeSort(vec, q + 1, r); MergeArray(vec, p, q, r);&#125;void MergeArray(vector&lt;int&gt;&amp; vec, int p, int q, int r) &#123; vector&lt;int&gt; res(r - p + 1); int k = 0; int i = p; int j = q + 1; while (i &lt;= q &amp;&amp; j &lt;= r) &#123; if (vec[i] &lt;= vec[j]) &#123; res[k++] = vec[i++]; &#125; else &#123; res[k++] = vec[j++]; &#125; &#125; while (i &lt;= q) &#123; res[k++] = vec[i++]; &#125; while (j &lt;= r) &#123; res[k++] = vec[j++]; &#125; for (int i = 0; i &lt;= r - p; i++) &#123; vec[p + i] = res[i]; &#125;&#125; 快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void QuartSort(vector&lt;int&gt; &amp;vec, int p, int r);int partition(vector&lt;int&gt; &amp;vec, int p, int r);int main() &#123; vector&lt;int&gt; arr = &#123;2, 121, 115, 23, 12, 24&#125;; /* 快速排序 * 快排也是分治的思想，对数组的任意一段，从中选一点，使得这个点左边的元素比该点小， * 右边的元素比该点大。分治+递归 * 时间复杂度：o(nlogn), 空间复杂度：o(1) */ int n = arr.size(); QuartSort(arr, 0, n - 1); cout&lt;&lt; &quot;排序之后：&quot;; for (auto num : arr) &#123; cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; return 0;&#125;void QuartSort(vector&lt;int&gt;&amp; vec, int p, int r) &#123; if (p &gt;= r) return; int q = partition(vec, p, r); QuartSort(vec, p, q - 1); QuartSort(vec, q + 1, r);&#125;int partition(vector&lt;int&gt;&amp; vec, int p, int r) &#123; int i = p; int povid = vec[r]; for (int j = p; j &lt; r; j++) &#123; if(vec[j] &lt; povid) &#123; if (j == i) &#123; i++; &#125; else &#123; int temp = vec[i]; vec[i++] = vec[j]; vec[j] = temp; &#125; &#125; &#125; int temp = vec[i]; vec[i] = vec[r]; vec[r] = temp; return i;&#125; 单链表的归并排序1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if (!head || !head-&gt;next) &#123; return head; &#125; ListNode* mid = findMid(head); ListNode* newHead = mid-&gt;next; mid-&gt;next = nullptr; ListNode* left = sortList(head); ListNode* right = sortList(newHead); return merge(left, right); &#125; ListNode* findMid(ListNode* head) &#123; ListNode* slow = head; ListNode* fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125; ListNode* merge(ListNode* l1, ListNode* l2) &#123; if (!l1) return l2; if (!l2) return l1; if (l1-&gt;val &lt;= l2-&gt;val) &#123; l1-&gt;next = merge(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = merge(l1, l2-&gt;next); return l2; &#125; &#125;&#125;;","tags":["计算机技术"]},{"title":"宝贵的人生意见","path":"/2024/03/04/宝贵的人生意见/","content":"关于批评：对一个东西最好的批评，就是做出一个新东西来替代ta。 关于自我投资花钱投资自己，学习新技能，能产生丰厚的回报。 成为什么样的人要成为一个受人尊重，有影响力，行为不能被人预测的人。重要的是不可取代。 如何待人给别人第二次机会，但不能再多了。 切忌忙碌放弃多任务，生活要专注。 花费长的时间，搞懂一个你以前从未了解的事情，远比走马观花看更多的事情的收益大。 不花费时间彻底弄懂一件事情，而匆匆忙忙了解事物，既浪费了时间，又没有真正掌握。表面上效率高，实际上效率为0 发现新事物经常性打破常规，试着换一下家具摆放位置，换一条路回家，打破常规，会有新的发现。 生活在哪里生活的地方可以影响你，但这是一个可以改变的影响因素。 如何定义自己用喜欢的东西、擅长的东西定义自己，而不是讨厌的东西 关于争论争论无意义，大部分争论到最后和争论本身无关，更多的是自我保护和自尊心。避免争论。 什么是成功先定义成功，然后实现它。先射箭，然后画靶心。 关于爱好人生需要一个事情，这个事情上你不需要追求经济回报和效率，但是你可以沉醉于此，这是一种放松和娱乐。哪怕你并不能够做得很好，但ta将使你生活充满意义。 做事要节制，除了自己热爱的事情。 关于想法面对重要的事情，允许改变想法。 过去对某一件事的想法并不现实，在你有了更深入的了解之后，你应该抛弃之前错误的想法，而不是坚持错误的观点。 不要犯同样的错。要犯新错误。 关于行动力人经常有新想法，但是5分钟之后就消失了。所以要利用好这个时间，立马去做，及时行动。 人会有惰性，会有很多弱点。我们应该利用弱点，而不是对抗。 分清楚重要的事情和紧急的事情重要和紧急的事情，大概可以分的清楚，但是不一定能够优先执行重要的事情。在工作中，这甚至可以说是一种隐形的权利，需要通过你的实力去争取。 把最重要的事情，当做最重要的事。这就是最重要的事。 如何面对困难当你陷入困境、无法继续下去的时候，专注于力所能及的小事上面，这能够推进事情的发展。 同理，当你感到绝望、悲观、焦虑等负面情绪中的时候，试着去专注一件小事，这也是有效的。 关于决策对未来的事情，善于规划和推理。时时刻刻想接下来怎么做，这样会使得决策更明智。 关于待人喜欢和厌恶一个人是你的权利。但是对于任何人，哪怕是你讨厌的人，都要给于基本的尊重。 不要把对别人的喜好挂在脸上。于人于己都是百利而无一害。 成熟学习如何从你讨厌的人身上学到东西。 学习倾听他人。让别人把想说的话说完。这才能更好的沟通。 有时候不是你的错，但也是你的责任。 乐观悲观正确且无用，既然无用，那就抛弃。 不要害怕问（这是我的一大弊病）听上去愚蠢的问题，大部分人也想问，只是不好意思开口。 不好意思是一个恶习，必须改掉。 不要过度计划人生需要更多的尝试，而不是制定宏伟的计划。 主动学习从“做不了”到“学着做”，主动学习。 自我评价不要用别人的评价体系衡量自己。 不在意别人的眼光，为自己而活。 深入学习深入了解一门学科，这样的学习是最有效的。 结识新朋友请客吃饭永远是有效的方法，而且简单易行。这对老朋友很有效，也是结交新朋友的好方法。 关于痛苦既然痛苦和挫折无法避免，那么我们可以坦然接受，而不是饱受折磨。 负债永远不要通过借债来购买价值不断贬损的东西。 最好的学习方法把自己学到的东西，教给别人。（费曼学习法） 成长每年都比过去的一年好一点点，年复一年。 寻找与你意见不一致的聪明人，并与他学习。 成长会让你对过去的自己感到难堪。 作为一个成熟的人，衡量你成长的尺度是，你愿意进行多少令人不舒服的谈话。 从你不喜欢的人那里学习，从愚蠢、刻薄的人身上学到你可以学习的东西。 如何选择当你难以抉择的时候，选择一条可以带来改变的路。 保持情绪我可以选择今天不生气。 保持乐观。悲观者正确，乐观者胜利。 习惯毅力不可靠，习惯最可靠。 通过养成习惯来获取进步。 做事情，习惯比数量更重要。 当你想要放弃的是，告诉自己再坚持最后一下。 相信如果别人拿出一个不寻常的说法试图说服你，请他拿出具有说服力的证据。 了解对方的真实想法不断挖掘，让对方在初次陈述之上继续说，第三次往往才能得到最接近的答案。 突破自己每个人都害羞，都犹豫，你要先伸手，去做吧。 反思自己难得多，但收益同样也多。 如何变有趣你对别人越感兴趣，别人越觉得你有趣。 第二次请求定律第一次请求别人遇到拒绝的情况下，过段时间再试试，成功率高的惊人。 做事在行动之前，不要进行内心的权衡，这时候消耗能量思考是徒劳，尽管去做就是了。 做事，尽管去做。 做到卓越，那就要日复一日、重复反复做。 先做事，再改进。 先行动，再反思。 拒绝考虑他人感受没有他人这一说，只有很多的个体。不要在意他人的感受。 不要刻意追求他人的认同。 不要管别人怎么看待你，因为他们根本没看你。 关注小事拒绝宏大叙事，专注小事。否则一事无成。 搭档寻求建议，你将获得一个搭档。 己所不欲，勿施于人。 思考思考不光用大脑，你还需要散散步、走走路，或者画一画。 消费购买你买得起的品质最好的工具，而不是最便宜的或者最贵的。 承担责任用于承担责任，会让你变得强大。 不要咒怨咒怨不会影响对方，只会伤害自己。放在咒怨，因为它是毒药。 专注服务用户做事的准则是服务好用户，而不是打败对手。 拒绝学会说“不”，哪怕是没有理由的“不”。 坚持大多数成功只是因为坚持。 不要着急稳重，不要焦急。打乱自己更容易被别人欺骗。 旁观者清你将成为什么样的人，你身边的人最清楚，你的亲戚、朋友、顾客等。 你是什么样的人，看看周围的朋友就知道了。 判断自己要不要做一件事别人邀请你未来做一件事，你要问自己，假如明天做这件事，你愿意吗。这就是答案。 对待别人的请求绝不要在电话里答应别人的请求和建议。 急迫的请求，一般来说都是披着请求的骗局。 如何道歉要真诚、具体、迅速的道歉，千万不要找借口，找借口是不诚心的做法。 追求幸福幸福求而不得，当你掌握一门技能，拥有一项能力，你自然会充实、幸福。 不要追求完美，切记。 没有完美，只有进步。完成胜过完美。 如何让对方安静下来发生争吵时，轻声细语能让对方安静下来。 争吵时不要对立，要就事论事，不要挖坟，不要算账。 保持冷静。冷静会传染给别人。保持冷静就是在帮助他人。 借钱无论是借钱，还是借东西给别人，要抱着送给对方的心态。 问自己 “为什么我要做这件事”这个问题需要好好回答。这个问题贯穿你的一生。 克服焦虑和急迫感学习如何心安理得的休息20分钟。 不要受制于任何紧急事项。聚焦于重要的事情。 不要被紧迫感裹挟！！！ 每周都要有固定的时间放空自己，休息大脑，以及思考一些人生中重要的事情。 赞美和道歉赞美和道歉对自己来说，是免费的事情，同样也是最有价值的事情。不要吝啬。 失败、成功对失败不要刻意，不断的失败能够不断的获得经验。 能预料到的失败，不是失败。 一朝成功，源于背后多年的努力。积累很重要，实力让你在机会面前胜出。 少做承诺，多做实事。 成功就是要帮助别人完成事情。你要做有利于别人的事情。 退路三思而后行。做事情要想好退出策略，做好最坏的打算。 做事之前多做准备，这是应对错误的保障，是防范风险的保障。 积累一个好想法，源于无数的坏想法。 钱和时间每个人的时间都是有限的。钱最大的用处是，购买别人的时间为你工作。 工作是为了成就自己。 找出你一天中效率最高的时间，并好好利用这段时间。 恐惧恐惧让人愚蠢。不要相信一个恐惧的人做出的事情。 朋友年轻时结交比你年长的朋友。 别人告诉你哪个地方不对，通常是对的； 别人告诉你怎么解决问题，通常是错的。 与陌生人交朋友时，让自己显得和别人是同类人。 与人交流时，多赞美。这样你有求于人的时候，他们会帮助你。 发现别人的优点。 改变改变想法很困难。 要通过改变行为来改变想法。 寻求改变的做法是付诸于行动。 不要担心什么时候开始，持续行动。 观念改变不了你，行动可以。 思想需要行动。 行动大于思想。 复利财富、人际关系、知识都源于复利。 一天完不成多大的事情，这让我们失望。 但是十年能完成多大的事情，这是我们忽略的。所谓长期主义，就是要持之以恒，坚持下去，时间会告诉你答案。 休息很重要假期、休息、漫无目的的散步，都是必要的。 自信说话要自信。 听别人说话要仔细。 做决定不要在深夜做决定。 深夜想买的东西，第二天早上都可以买。 独处学习如何在独处时不孤独。独处是创造力涌现的必要条件。 交流想要了解别人的想法，不要直接问，想办法让别人主动说出来。 不必过分谦虚带着感谢接受赞美，即使你认为自己不配得到这份赞美。 工作聪明的人，不会为了金钱而拼命工作。 完美主义完美主义害死人。 先大致完成，再一点点修理。迭代升级是王道。 写一本好书的唯一方法是先写一本糟糕的书。 投资投资要追求平均的回报，持有超过平均水平的时间。 沟通提升沟通的技巧很重要。 问题解释问题，是解决问题的一部分。 理解问题所在，可能会给你以启发。 模仿模仿他人，是一个很好的方法。 求职求职是很重要的事，花多长时间都不为过。 保持怀疑不要简单地相信你认为自己相信的一切。 有趣有趣就是用一种不同寻常的方式讲述自己的故事。 快乐不快乐是因为想要别人拥有的东西。 快乐是因为想要自己已经拥有的东西。 制造话题如何制造吸引别人的话题。 简化、简化、简化，然后夸张。 换位思考从别人的角度思考问题。 关于过去无法改变过去发生的事情，但是我们可以改变对这些事情的看法。 重要的不是你经历了什么，而是你如何对待经历的事。 担忧担忧毫无意义，你担心的事，99%不会发生。 任何挫折都是暂时的。 打破常规经常性打破自己的常规，对不感兴趣的事情也加以了解，能够得到一些惊喜。 倾听倾听会让说话的人认可你。 倾听是为了听出说话的人的弦外之意。 要允许别人有和你不一样的观点。 反思每天反思、改进自己做事的方式，是事半功倍的方法。 幸福和别人比较，你会不幸福。 和昨天的自己比较，你会得到幸福。 活在当下现在就是你的黄金岁月。","tags":["随笔"]},{"title":"Linux基础知识总结","path":"/2024/03/04/Linux基础知识总结/","content":"什么是.bashrc文件 .bashrc对linux普通用户来说，是一个配置文件，当你登录这个用户的时候，系统会率先执行该文件。因此用户可以用.bashrc自定义来配置shell环境。 比如指定一些路径，再比如设置一些短命令。需要注意的是，修改完.bashrc后，需要执行 source .bashrc来加载使之生效。 在Linux中，”cc”是C语言编译器的默认命令别名。它通常指向系统上安装的C编译器，如GCC（GNU Compiler Collection）或Clang。使用”cc”命令可以编译和链接C语言程序。例如，要编译名为”hello.c”的C程序，可以使用以下命令： 1cc hello.c -o hello 之后会生成hello的可执行文件。（不指定-o，则会默认生成可执行文件 **a.out **） 库函数和系统调用系统调用：操作系统提供的接口。 实现一个功能要调用好多系统调用，因此继续封装，这就有了库函数。 CPU有两种运行模式：一种是内核模式；另一种是用户模式。 上下文切换：系统调用必须从用户模式切换到内核模式下运行。 Linux启动Linux内核启动的时候，建立一个init进程，是1号进程，没有0号进程。 然后所有其他的进程都是从init进程中fork出来的。就像Linux的文件系统一样，Linux的进程也构成了一个树形结构。 Linux基础命令。如何了解一个命令？ 有两种方法，一种是 whatis，一种是man。 whatis是一种简单的查询方式；man是一种复杂的查询方式。 12whatis lsman ls 终止和暂停命令终止命令：ctrl + c 暂停命令： ctrl + z 查看可执行命令的位置which 1which ls poll和selectpoll和select都是多路复用的系统调用，用于在一个线程中同时监听多个IO事件。 当有事件发生，两个函数都会返回事件发生的文件描述符的列表。 在等待事件的时候，poll或select是阻塞状态的，当然不会一直阻塞，可以设置超时参数。 两者的区别： select的最大文件描述符数受到限制。poll没有限制。需要同时监听大量文件描述符的时候，推荐使用poll select的效率低于poll select的可移植性好，一些老的系统可能不支持poll 多线程通信 共享内存：生产者-消费者模型。生产者线程将数据写入共享内存，消费者线程从共享内存中读取数据。shmget 是一个系统调用，用来创建共享内存。 消息队列：网络编程中，服务端线程通过消息队列将收到的客户端线程的消息发给处理线程进行处理。msgget是一个系统调用，用来创建一个消息队列。 信号量：（保证原子操作）sem_init 是一个初始化信号量的函数。多个线程访问或修改同一个变量的时候，线程先等待信号量，然后进行操作，最后释放信号量。抱着同时只有一个线程能够访问变量，保证了线程安全。（互斥锁也是类似，互斥锁是一种二进制的同步方法，保证任意时刻只有一个线程可以访问共享变量。还有一种叫做自旋锁，自旋锁也是保证任意时刻只有一个线程访问共享变量。自旋锁和信号量不同的是，自旋锁不会使线程阻塞，而是一直自旋等待，直到锁被释放，获取到锁为止。自旋锁减少了线程上下文切换的开销，适用于临界区很小，持有锁的事件很短的情况，比如一些赋值、判断等语句） 信号量和互斥锁的区别： 互斥锁一次只允许一个线程访问共享资源；信号量是可以限制同时访问共享资源的线程数，允许多个线程同时访问。 互斥锁只有两种状态（锁定，放锁）；信号量可以有多种状态。 条件变量：适用场景：当一个线程需要等待另一个线程的特定条件发生时，可以使用条件变量进行多线程通信。比如生产者-消费者模型。生产者生产完成，然后notify()通知给消费者。消费者此前一直处于wait()等待状态。通过条件变量的 wait()、notify() 和 notifyAll() 方法，实现了生产者与消费者之间的同步与通信。 在生产者-消费者模型中，使用条件变量或者共享内存都可以实现通信。两者区别之处在于： 使用条件变量时，通常需要使用互斥锁来保护共享资源的访问，防止竞态条件（多线程下，程序结果依赖于线程执行顺序。如果执行顺序不一样，会导致不同的结果）。 使用共享内存时，通常也是需要采用锁机制（比如互斥锁）来保护共享内存的访问，防止竞态。 条件变量适用于基于特定条件的通信； 共享内存适用于需要共享大量数据或者频繁读写数据的场景。 管道：生产者线程负责向管道发送数据，消费者线程负责从管道接收数据，通过管道实现了线程之间的通信。 套接字：socket一般是用在网络通信，同一台机器上的两个线程也可以使用socket通信。 进程间通信（IPC Inter-Process Communication） 管道：匿名管道（父子进程、同父的子进程之间通信）；命名管道（无关的进程之间的通信） 消息队列：（发送队列、接收队列） 共享内存：缓冲区缓存（postgresql的缓冲区缓存可以视为是一种共享内存的机制） 信号量 socket 文件锁：通过在文件上设置锁。多个进程通过获取文件锁来协调对共享文件的访问。 Linux常见信号 SIGINT：中断 SIGQUIT：退出 SIGTSTP：暂停 SIGCONT：继续 SIGALRM：定时器","tags":["计算机技术"]},{"title":"幸福的积分","path":"/2024/03/01/幸福的积分/","content":"在人的一生中，究竟什么是最重要的？ 工作、金钱，还是爱情亲情，都不是。最重要的是时间。 因为时间是限制你实现种种愿望的最大障碍。 当你用金钱来衡量自己的一生的时候，其实是错误的。因为你没有考虑时间成本。 所以，在你的人生中，你应该用时薪作为衡量的标准，而不仅仅是金钱。 幸福是什么？ 幸福是一种主观感受，是快乐、满足，是当下的心理体验。 人生的幸福，是一生中每个时刻幸福度的积分，而幸福度是一种只和当下有关的主观体验。 脱离社会主流价值观不是摆烂，也不是躺平。明白自己真正想要的生活并去实现它，而不是用社会的价值观念绑架自己。幸福要自定义，不要社会强行赋予你答案。 你为什么要工作？ 第一反应是钱。 我工作的唯一目的是赚足够的钱，然后早日实现彻底不工作。如果抱着这样的想法，大概你工作的时候是痛苦的，并且作为一个普通人，你永远也不会实现所谓的财务自由。 作为普通人来说，即便是你将所有的生命都投入赚钱中，你也赚不了多少钱，你赚到的钱也买不回失去的幸福。 普通人和富人的区别是：你的时薪没有高到值得你投入所有时间到工作。那么与其这样，为什么要把珍贵的时间投入廉价的工作当中呢 但是你又不能不工作，因为你需要金钱来维持一定的物质生活条件。 所以，衡量一份工作是否适合你，第一因素应该是快乐，第二才是薪水。 因为普通人的一生最美好的时光，必定是要工作的。所以要想让你的大部分人生是快乐的，你就不应该选择一份让自己痛苦的工作，再多的钱也不应该。 你需要计算，你想要的理想的生活需要多少钱来支撑。这个理想的生活是要带给你幸福的，但它不应该受消费主义的影响，必须是你客观的考量之后核算出来的。 工作是为了获得经济回报以支撑你现在的物质生活水平，直接的说是获得快乐生活的成本，上班是手段不是目的。你不能为了获得更高的经济回报，而逼迫自己从事一份痛苦的工作。 你也不能为了追求更高的经济回报，而牺牲自己的时间去内卷，为了向上奋斗而变得烦燥焦虑，这就失去本心了。 应该怎样生活？ 生活是一切，工作只是工作。 生活不是工作。你参加工作需要量化目标，制定计划。但是生活是轻松的，无需把工作的那一套逻辑拿到生活中。生活不需要KPI，也不需要OKR。生活也不必时刻保持向上移动。 什么样的工作是理想的工作？ 记住，工作，首先应当是为了乐趣。所以，衡量标准有以下三点： 你能从工作中找到快乐。 你能从工作中获得一定收入，这个收入可以支撑你的物质条件。 工作不应该996，但一定是需要你持续投入。不应该敷衍了事。","tags":["随笔"]},{"title":"first.md","path":"/2024/02/29/first-md/","content":"基于github搭建个人博客，应该是目前来说免费且简单的一种方式。 搭建好之后，如何更新博客内容，步骤如下： 用git bash终端打开在本地目录下（我的目录是：D:\\个人资料\\fxy_github_blog\\） 输入命令：hexo new &#39;xxx-blog&#39;，创建文件名，也就是文章标题。 在目录source\\_posts，可以找到上一步创建的文件，填写内容保存。 生成html文件：hexo g 上传到github：hexo d 访问：fxy0224.github.io&#x2F;"},{"title":"Hello World","path":"/2024/02/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]